# 算法的引入
## 1.算法的五大特性

### 输入：算法具有0个或者多个输入
### 输出：算法具有0个或者多个输出
### 有穷性：算法在有限的步骤后悔自动结束，不是无限循环，并且在一个可接受时间范围内
### 确定性：算法的每一步都有明确的含义，不会出现二义性
### 可行性：算法的每一步都是可行的。也就是说每一步都能执行有限的次数完成。

简单demo

如果a+b+c = 1000, 并且a^2+b^2=c^2 (a,b,c)为自然数，如何求出所有a,b,c所有的可能组合？

### 枚举法：
<pre>
    <code>
import time

start_time = time.time()
for a in range(0,1001):
    for b in range(0,1001):
        for c in range(0,1001):
            if a+b+c== 1000 and a**2 + b**2 == c**2 :
                print("a,b,c:%d, %d, %d" %(a,b,c))

end_time = time.time()

print("time:%d" % (end_time-start_time))
    </code>
</pre>

运行次数: T = 1000 * 1000 * 1000 * 2
         T = N * N * N* 2
时间复杂度: T(n) = n^3 *2

### 优化第二版：减少运算步骤
<pre>
    <code>
import time

start_time = time.time()
for a in range(0,1001):
    for b in range(0,1001-a):
        c = 1000 - a - b
            if a**2 + b**2 == c**2 :
                print("a,b,c:%d, %d, %d" %(a,b,c))

end_time = time.time()

print("time:%d" % (end_time-start_time))
    </code>
</pre>

假设整个代码的时间复杂度为f(n)， 如果n^3记做g(n), 则整个函数可以写为f(n) = g(n) * 2

在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，则函数f与函数g的特征相似。

### 大O计法，The Big O

时间复杂度为 T(n) = O(g(n)) ,则O(g(n))为该算法的渐近时间复杂度，

简称时间复杂度 T(n)。